# README for Assignment 2: Router

Name: Kaiqiang Jiang

JHED: kjiang17@jh.edu

---

**DESCRIBE YOUR CODE AND DESIGN DECISIONS HERE**

This will be worth 10% of the assignment grade.

Some guiding questions:
- What files did you modify (and why)?
- What helper method did you write (and why)?
- What logic did you implement in each file/method?
- What problems or challenges did you encounter?



# Overall logic architecture

![./process_chart.jpg](.\process_chart.png)

# Modified files and function description

### sr_router.c

##### main method

```c++
void sr_handlepacket(struct sr_instance* sr,
        uint8_t * packet/* lent */,
        unsigned int len,
        char* interface/* lent */)
```

The basic processing logic is in **sr_handlepacket** function. It is called whenever our router receives packages. Based on different IP package types and Transport segment types, we need to perform different operations, such as sending ARP replies or forwarding packages.

1. Received IP package

   If the router receives IP packages, which is distinguished by ethterype. First, I verified the checksum and length of the packages to make sure that they are not broken. Then I need to check whether it is destined to one of our router's interfaces which is performed via matching the interfaces with the packages' destination IP address. If it is destined to interfaces, I distinguish its protocol type:

   - ICMP

     If the packages contain ICMP information, I check the icmp_type field. If it is an ICMP request, the router need to send ICMP reply which is achieved in the helper function **send_icmp_reply** below.

     If not ICMP request, I simply discard the package.

   - TCP/UDP

     If icmp_type  field is 6 or 17, which stands for TCP/UDP payload, I send **port unreachable, type 3, code 3**, this is an ICMP error message and its header is different from the normal ICMP reply. Hence, I use helper method **send_icmp_error** below.

   If it is not destined to router interfaces, then the router needs to forward the package to the next hop. First, since we are forwarding, we need to decrement TTL by 1. If TTL equals 0, I send **type 11, code 0** ICMP error message. Then I check whether the target IP address matches one of router's entries using the longest prefix match. If not found the outgoing entry, I send **type 3, code 0** destination port unreachable ICMP error message. However, if found, one thing I still don't know is the destination MAC address. Therefore, I use ARP to find MAC. If there exists matched MAC in ARP the cache, then the package can be simply sent. If no match is found in ARP cache, then I need to broadcast ARP request by putting the incomplete packages in the request queue through **sr_arpcache_queuereq** method.

2. Received ARP package

   Unlike IP package, the ARP package contains different network layer header. It can be divided into request and reply. If router receives request, it means other hosts are trying to connect to this router and router should encapsulate MAC address and send back to sender. If it is an ARP reply, it means now we can send packets waiting for this MAC in the request queue. So I send every previos packets waiting for this MAC.

##### helper method

```c++
void send_icmp_reply(struct sr_instance* sr,
        uint8_t * packet/* lent */,
        unsigned int len,
        char* interface/* lent */)
```

This function is used to send ICMP reply given ICMP request. I malloc an empty package with the same length of ICMP request, memcopy the original packet, set type and code to 0, swap the destination and source IP and MAC address, and send via **sr_send_packet**. What's important, the malloced space should be freed after sending.

```c++
void send_icmp_error(struct sr_instance* sr, uint8_t type, uint8_t code, uint8_t * oriIPPacket, uint32_t targetIP, uint32_t sourceIP, unsigned int oriLen, uint8_t * oriEtherPacket, unsigned int oriEitherLen)
```

This function is used to send ICMP error. Unlike the ICMP reply which is sent after receiving ICMP request, ICMP error message is generated by the router itself. So all the fields in the ethernet, IP, ICMP header should be manually set. This error message doesn't contain any payload, only send the headers. I include the oriIPPacket as a parameter because the ICMP data field should contain original IP header information. After setting the header fields, I forward the package in the same way as forwarding IP packages described above.

```c++
struct sr_rt *longestPrefix(struct sr_rt * entries, uint32_t ip)
```

 What's more, I have to compute the longest prefix match of giving IP address. This function iterate through all outgoing destination of router and find the longest match in IP. 

### sr_arpcache.c

In this file, I implement the logic of handling ARP cache. There are two main functions to implement.

```c++
void sr_arpcache_sweepreqs(struct sr_instance *sr)
```

This function is called every second. For each request in the ARP cache, we determine whether to resend or not by calling **handle_arpreq.** 

```c++
void handle_arpreq(struct sr_instance *sr, struct sr_arpreq *request)
```

For each request, if time has passed for 1 second, we resend the request. For each request, we need to send ARP request through every interface and set the destination MAC address to all 1 to indicate broadcast. If resend times are greater than 5, I send **type 3, code 1** ICMP error message and destroy the request queue.



# Problems encountered

- For each outgoing package, I have to malloc a new space and remember to free the malloced space after sending. We should leave the original incoming package to be freed by sr_arpreq_destroy.

- Some fields like IP_DF, ethertype_ip must use htons function to convert, or the real value will be set to zero and cause errors. However, some smaller value like ip_protocol_icmp can be unconverted.

- The checksum field should be computed at last. For example, I have to set the ICMP data field before computing the checksum, or the receiver will simply drop the package because of wrong checksum and causing ineffective traceout.

  











